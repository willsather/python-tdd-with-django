# Section 5: TDD with Django REST Framework and Machine Learning

## Machine Learning - Decision Tree Introduction

* Data and data science is considerably more available
* Using a decision tree for simplicity
    * At the core, creates a tree of decisions based on input, to predict the output
    * Has lots of value, but primarily taking inputs and using existing data to predict outputs of new data
    * Easier to test as outputs won't change regardless of repetition (not always the cse in machine learning)
* Has drawn concerns with how to best TDD / approach solving problems
    * XP ?? Takes adaptation
    * Models are built on setting desired outcome before building
    * This learning path won't focus on any of the nuances (Later in different post??)
* This example will be bare bones are quite simple
    * Palmer Penguins CSV Data set
    * Focus more on testing `/predict` endpoint (Testing the model as a black box)
        * Included the model creation code as well (Link to it, or just show it)

## Add Properties to `Penguin` object

Before, you had just three properties on the `Penguin` objects (island, body_mass, and gender), but now, in order to
continue this example, you must add some more properties to the object to fully encapsulate all the attributes of a
Penguin. The new penguin object should resemble:

```python
class Penguin(models.Model):
    SEX_CHOICES = (
        ('MALE', 'male'),
        ('FEMALE', 'female'),
    )

    island = models.CharField(max_length=50)
    sex = models.CharField(max_length=6, choices=Size.choices)
    bill_length_mm = models.DecimalField(max_digits=2, decimal_places=1)
    bill_depth_mm = models.DecimalField(max_digits=2, decimal_places=1)
    flipper_length_mm = models.IntegerField(min_value=0)
    body_mass_g = models.IntegerField(min_value=0)
```

where you not only have more attributes, but also have some input validation. This input validation is used by Django
REST Framework to automatically ensure your `Penguin` object doesn't have any values it's not supposed to. For example,
the new model utilizes a `choices` parameter for `CharField()` which won't allow any inputs other than the specified
values.

### Migrations

Due to making changes on the `Penguin` model, you will now have to inform Django REST Framework of these changes as it
is handling your database and in turn, also the migrations. For a refresher, this can be accomplished with the two
commands:

```bash
$ python manage.py makemigrations

Migrations for 'penguins':
  penguins/migrations/0002_remove_penguin_body_mass_remove_penguin_gender_and_more.py
    - Remove field body_mass from penguin
    - Remove field gender from penguin
    - Add field bill_depth_mm to penguin
    - Add field bill_length_mm to penguin
    - Add field body_mass_g to penguin
    - Add field flipper_length_mm to penguin
    - Add field sex to penguin

```

```bash
$ python manage.py migrate

Operations to perform:
  Apply all migrations: admin, auth, contenttypes, penguins, sessions
Running migrations:
  Applying penguins.0002_remove_penguin_body_mass_remove_penguin_gender_and_more... OK
```

Finally, before you can go back to debugging and using your server, you must update the `serializer.py` file to
correctly utilize all the new attributes:

```python
class PenguinSerializer(serializers.ModelSerializer):
    class Meta:
        model = Penguin
        fields = ('island', 'body_mass_g', 'sex', 'bill_length_mm', 'bill_depth_mm', 'flipper_length_mm')
```

and update your test file that is creating the basic `Penguin` objects:
```python
class PenguinViewsTest(TestCase):
    @classmethod
    def setUpTestData(cls):
        Penguin.objects.create(island='fakeIsland1', body_mass_g=0, sex='female', bill_length_mm=0.0,
                               bill_depth_mm=0.0, flipper_length_mm=0)
        Penguin.objects.create(island='fakeIsland2', body_mass_g=0, sex='male', bill_length_mm=0.0,
                               bill_depth_mm=0.0, flipper_length_mm=0)
```
## Steps

1. Create `/predict` endpoint
    1. New controller/view with just `POST`
    2. Make call to `service.py` where business logic will live
        1. TDD the service
        2. Validate a few paths through view tests (almost like an integration test)

## Create `POST /predict` endpoint

To start, you are going to yet again create another View which will primarily handle the `POST` on `/predict` URL. This
new view will take a `Penguin` object as an input, and will return a string output of the predicted `Penguin` species.

At this point, the `test_views.py` is getting quite long, so you can break it up like this:

```text

```
So, you can create another test that will start this process like this:

```python


```

Once you have a failing test, you can create the view by:

```python


```

To actually use this view, you must add it to your `urls.py` in order for Django REST Framework to recognize it:

```python 

```

## Wrap Up

## Continue Learning

[...]()
